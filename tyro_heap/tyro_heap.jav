get_pc_thunk_bx: 0x8048570
.init:
:
 8048448: PUSH EBX
 8048449: SUB ESP, 0x8
 804844c: CALL 8048570 <__x86.get_pc_thunk.bx> ; EBX = 0x8048451
 8048451: ADD EBX, 0x1baf
 8048457: MOV EAX, [EBX-0x4]
 804845d: TEST EAX, EAX ;
 804845f: JZ 0x8048466 ; if(EAX) {
 8048461: CALL 8048500 <__gmon_start__>
; }
 8048466: ADD ESP, 0x8
 8048469: POP EBX
 804846a: RET
.plt:
:
 8048470: PUSH DWORD [0x804a004]
 8048476: JMP DWORD [0x804a008]
 804847c: ADD [EAX], AL
 804847e: ADD [EAX], AL
setbuf:
 8048480: JMP DWORD [0x804a00c]
 8048486: PUSH DWORD 0x0
 804848b: JMP 0x8048470
printf:
 8048490: JMP DWORD [0x804a010]
 8048496: PUSH DWORD 0x8 ; '\x08'
 804849b: JMP 0x8048470
free:
 80484a0: JMP DWORD [0x804a014]
 80484a6: PUSH DWORD 0x10 ; '\x10'
 80484ab: JMP 0x8048470
getchar:
 80484b0: JMP DWORD [0x804a018]
 80484b6: PUSH DWORD 0x18 ; '\x18'
 80484bb: JMP 0x8048470
alarm:
 80484c0: JMP DWORD [0x804a01c]
 80484c6: PUSH DWORD 0x20 ; ' '
 80484cb: JMP 0x8048470
malloc:
 80484d0: JMP DWORD [0x804a020]
 80484d6: PUSH DWORD 0x28 ; '('
 80484db: JMP 0x8048470
puts@@GLIBC_2.0:
 80484e0: JMP DWORD [0x804a024]
 80484e6: PUSH DWORD 0x30 ; '0'
 80484eb: JMP 0x8048470
system:
 80484f0: JMP DWORD [0x804a028]
 80484f6: PUSH DWORD 0x38 ; '8'
 80484fb: JMP 0x8048470
__gmon_start__:
 8048500: JMP DWORD [0x804a02c]
 8048506: PUSH DWORD 0x40 ; '@'
 804850b: JMP 0x8048470
exit:
 8048510: JMP DWORD [0x804a030]
 8048516: PUSH DWORD 0x48 ; 'H'
 804851b: JMP 0x8048470
__libc_start_main:
 8048520: JMP DWORD [0x804a034]
 8048526: PUSH DWORD 0x50 ; 'P'
 804852b: JMP 0x8048470
__isoc99_scanf:
 8048530: JMP DWORD [0x804a038]
 8048536: PUSH DWORD 0x58 ; 'X'
 804853b: JMP 0x8048470
.text:
:
 8048540: XOR EBP, EBP
 8048542: POP ESI
 8048543: MOV ECX, ESP
 8048545: AND ESP, -0x10
 8048548: PUSH EAX
 8048549: PUSH ESP
 804854a: PUSH EDX
 804854b: PUSH DWORD 0x80489c0 ; '\xf3\xc3'
 8048550: PUSH DWORD 0x8048950 ; 'UW1\xffVS\xe8\x15\xfc\xff\xff\x81\xc3\xa5\x16'
 8048555: PUSH ECX
 8048556: PUSH ESI
 8048557: PUSH DWORD 0x804876e ; 'U\x89\xe5\x83\xe4\xf0\x81\xec\xa0'
 804855c: CALL 8048520 <__libc_start_main>
 8048561: HLT
 8048562: NOP
 8048564: NOP
 8048566: NOP
 8048568: NOP
 804856a: NOP
 804856c: NOP
 804856e: NOP
__x86.get_pc_thunk.bx:
 8048570: MOV EBX, [ESP]
 8048573: RET
 8048574: NOP
 8048576: NOP
 8048578: NOP
 804857a: NOP
 804857c: NOP
 804857e: NOP
deregister_tm_clones:
 8048580: MOV EAX, 0x804a047
 8048585: SUB EAX, 0x804a044
 804858a: CMP EAX, 0x6 ;
 804858d: JA 0x8048590 ; if(EAX <= 0x6) {
 804858f: RET
; }
 8048590: MOV EAX, 0x0
 8048595: TEST EAX, EAX ;
 8048597: JZ 0x804858f ; } while(!EAX)
 8048599: PUSH EBP
 804859a: MOV EBP, ESP
 804859c: SUB ESP, 0x18
 804859f: MOV DWORD [ESP], 0x804a044
 80485a6: CALL EAX
 80485a8: LEAVE
 80485a9: RET
 80485aa: LEA ESI, [ESI+0x0]
register_tm_clones:
 80485b0: MOV EAX, 0x804a044
 80485b5: SUB EAX, 0x804a044
 80485ba: SAR EAX, 0x2
 80485bd: MOV EDX, EAX
 80485bf: SHR EDX, 0x1f
 80485c2: ADD EAX, EDX
 80485c4: SAR EAX, 0x1
 80485c6: JNZ 0x80485c9
 80485c8: RET
; }
 80485c9: MOV EDX, 0x0
 80485ce: TEST EDX, EDX ;
 80485d0: JZ 0x80485c8 ; } while(!EDX)
 80485d2: PUSH EBP
 80485d3: MOV EBP, ESP
 80485d5: SUB ESP, 0x18
 80485d8: MOV [ESP+0x4], EAX
 80485dc: MOV DWORD [ESP], 0x804a044
 80485e3: CALL EDX
 80485e5: LEAVE
 80485e6: RET
 80485e7: MOV ESI, ESI
 80485e9: LEA EDI, [EDI+0x0]
__do_global_dtors_aux:
 80485f0: CMP BYTE [0x804a084], 0x0 ;
 80485f7: JNZ 0x804860c ; if(BYTE [0x804a084] == 0x0) {
 80485f9: PUSH EBP
 80485fa: MOV EBP, ESP
 80485fc: SUB ESP, 0x8
 80485ff: CALL 8048580 <deregister_tm_clones>
 8048604: MOV BYTE [0x804a084], 0x1 ; '\x01'
 804860b: LEAVE
; }
 804860c: RET
 804860e: NOP
frame_dummy:
 8048610: MOV EAX, [0x8049f10]
 8048615: TEST EAX, EAX ;
 8048617: JZ 0x8048638 ; if(EAX) {
 8048619: MOV EAX, 0x0
 804861e: TEST EAX, EAX ;
 8048620: JZ 0x8048638 ; if(EAX) {
 8048622: PUSH EBP
 8048623: MOV EBP, ESP
 8048625: SUB ESP, 0x18
 8048628: MOV DWORD [ESP], 0x8049f10 ; ''
 804862f: CALL EAX
 8048631: LEAVE
 8048632: JMP 0x80485b0
 8048637: NOP
; }
 8048638: JMP 0x80485b0
create_item:
 804863d: PUSH EBP
 804863e: MOV EBP, ESP
 8048640: SUB ESP, 0x28
 8048643: MOV DWORD [ESP], 0x24 ; '$'
 ; malloc(0x24) allocation of 36 bytes
 804864a: CALL 80484d0 <malloc>
 804864f: MOV [EBP-0xc], EAX
 8048652: MOV EAX, [EBP-0xc]
 8048655: MOV DWORD [EAX], 0x80484e0 ; '\xff%$\xa0\x04\x08h0'
 804865b: MOV EAX, [EBP-0xc]
 804865e: LEAVE
 804865f: RET
win:
 8048660: PUSH EBP
 8048661: MOV EBP, ESP
 8048663: SUB ESP, 0x18
 8048666: MOV DWORD [ESP], 0x80489e0 ; '/bin/sh'
 804866d: CALL 80484f0 <system>
 8048672: LEAVE
 8048673: RET
read_a:
 8048674: PUSH EBP
 8048675: MOV EBP, ESP
 8048677: SUB ESP, 0x18
 804867a: MOV DWORD [ESP], 0x80489e8 ; 'give me input_a: '
 8048681: CALL 8048490 <printf>
 8048686: MOV EAX, [EBP+0x8]
 8048689: MOV [ESP+0x4], EAX
 804868d: MOV DWORD [ESP], 0x80489fa ; '%35s'
 ; scanf("%35s")
 8048694: CALL 8048530 <__isoc99_scanf>
 8048699: LEAVE
 804869a: RET
read_b:
 804869b: PUSH EBP
 804869c: MOV EBP, ESP
 804869e: SUB ESP, 0x28
 80486a1: MOV DWORD [EBP-0x10], 0x0
 80486a8: MOV DWORD [ESP], 0x80489ff ; 'give me input_b: '
 80486af: CALL 8048490 <printf>
 80486b4: CALL 80484b0 <getchar>
 80486b9: MOV [EBP-0xc], EAX
 80486bc: JMP 0x80486d3
 80486be: MOV EAX, [EBP-0x10]
 80486c1: LEA EDX, [EAX+0x1]
 80486c4: MOV [EBP-0x10], EDX
 80486c7: MOV EDX, EAX
 80486c9: MOV EAX, [EBP+0x8]
 80486cc: ADD EDX, EAX
 80486ce: MOV EAX, [EBP-0xc]
 80486d1: MOV [EDX], AL
 80486d3: CALL 80484b0 <getchar>
 80486d8: MOV [EBP-0xc], EAX
 80486db: CMP DWORD [EBP-0xc], 0xa ;
 80486df: JZ 0x80486e7 ; if(DWORD [EBP-0xc] != 0xa) {
 80486e1: CMP DWORD [EBP-0xc], -0x1 ;
 80486e5: JNZ 0x80486be ; } while(DWORD [EBP-0xc] != -0x1)
; }
 80486e7: MOV EAX, [EBP-0x10]
 80486ea: LEA EDX, [EAX+0x1]
 80486ed: MOV [EBP-0x10], EDX
 80486f0: MOV EDX, EAX
 80486f2: MOV EAX, [EBP+0x8]
 80486f5: ADD EAX, EDX
 80486f7: MOV BYTE [EAX], 0x0
 80486fa: MOV EAX, [EBP+0x8]
 80486fd: MOV [ESP+0x4], EAX
 8048701: MOV DWORD [ESP], 0x8048a11 ; 'got [%s]\n'
 8048708: CALL 8048490 <printf>
 804870d: LEAVE
 804870e: RET
free_heap_obj:
 804870f: PUSH EBP
 8048710: MOV EBP, ESP
 8048712: SUB ESP, 0x18
 8048715: MOV EAX, [EBP+0x8]
 8048718: MOV [ESP], EAX
 804871b: CALL 80484a0 <free>
 8048720: MOV EAX, 0x0
 8048725: LEAVE
 8048726: RET ; return 0x0;
get_choice:
 8048727: PUSH EBP
 8048728: MOV EBP, ESP
 804872a: SUB ESP, 0x28
 804872d: MOV DWORD [ESP], 0x8048a1b ; 'object id ?: '
 8048734: CALL 8048490 <printf>
 8048739: LEA EAX, [EBP-0xc]
 804873c: MOV [ESP+0x4], EAX
 8048740: MOV DWORD [ESP], 0x8048a29 ; '%d'
 8048747: CALL 8048530 <__isoc99_scanf>
 804874c: MOV EAX, [EBP-0xc]
 804874f: TEST EAX, EAX ;
 8048751: JS 0x8048760 ; if(EAX >= 0) {
 8048753: MOV EAX, [EBP-0xc]
 8048756: CMP EAX, [EBP+0x8] ;
 8048759: JG 0x8048760 ; if(EAX <= [EBP+0x8]) {
 804875b: MOV EAX, [EBP-0xc]
 804875e: JMP 0x804876c
; }
 8048760: MOV DWORD [ESP], 0xffffffff
 8048767: CALL 8048510 <exit>
 804876c: LEAVE
 804876d: RET
main:
 804876e: PUSH EBP
 804876f: MOV EBP, ESP
 8048771: AND ESP, -0x10
 8048774: SUB ESP, 0xa0
 804877a: MOV DWORD [ESP+0x18], 0xffffffff
 8048782: MOV DWORD [ESP], 0x1e ; '\x1e'
 8048789: CALL 80484c0 <alarm>
 804878e: MOV EAX, [0x804a060]
 8048793: MOV DWORD [ESP+0x4], 0x0
 804879b: MOV [ESP], EAX
 804879e: CALL 8048480 <setbuf>
 80487a3: MOV EAX, [0x804a080]
 80487a8: MOV DWORD [ESP+0x4], 0x0
 80487b0: MOV [ESP], EAX
 80487b3: CALL 8048480 <setbuf>
 80487b8: MOV DWORD [ESP], 0x8048a2c ; 'Tyro Heap'
 80487bf: CALL 80484e0 <puts@@GLIBC_2.0>
 80487c4: MOV DWORD [ESP], 0x8048a36 ; 'date'
 80487cb: CALL 80484f0 <system>
 80487d0: MOV DWORD [ESP], 0x8048a3b ; 'c) create heap object'
 80487d7: CALL 80484e0 <puts@@GLIBC_2.0>
 80487dc: MOV DWORD [ESP], 0x8048a51 ; 'a) read type a into object'
 80487e3: CALL 80484e0 <puts@@GLIBC_2.0>
 80487e8: MOV DWORD [ESP], 0x8048a6c ; 'b) read type b into object'
 80487ef: CALL 80484e0 <puts@@GLIBC_2.0>
 80487f4: MOV DWORD [ESP], 0x8048a87 ; 'f) free object'
 80487fb: CALL 80484e0 <puts@@GLIBC_2.0>
 8048800: MOV DWORD [ESP], 0x8048a96 ; 'e) run object function'
 8048807: CALL 80484e0 <puts@@GLIBC_2.0>
 804880c: MOV DWORD [ESP], 0x8048aad ; 'q) quit'
 8048813: CALL 80484e0 <puts@@GLIBC_2.0>
 8048818: MOV DWORD [ESP], 0x8048ab5 ; '::> '
 804881f: CALL 8048490 <printf>
 8048824: LEA EAX, [ESP+0x16]
 8048828: MOV [ESP+0x4], EAX
 804882c: MOV DWORD [ESP], 0x8048aba ; '%c'
 8048833: CALL 8048530 <__isoc99_scanf>
 8048838: NOP
 8048839: CALL 80484b0 <getchar>
 804883e: MOV [ESP+0x17], AL
 8048842: CMP BYTE [ESP+0x17], 0xa ;
 8048847: JZ 0x8048850 ; if(BYTE [ESP+0x17] != 0xa) {
 8048849: CMP BYTE [ESP+0x17], 0xff ;
 804884e: JNZ 0x8048839 ; } while(BYTE [ESP+0x17] != 0xff)
; }
 8048850: MOVZX EAX, BYTE [ESP+0x16]
 8048855: CMP AL, 0x63 ;
 8048857: JNZ 0x804888f ; if(AL == 'c') {
 8048859: CMP DWORD [ESP+0x18], 0x1f ;
 804885e: JG 0x804894b ; if(DWORD [ESP+0x18] <= 0x1f) {
 8048864: ADD DWORD [ESP+0x18], 0x1
 8048869: CALL 804863d <create_item>
 804886e: MOV EDX, [ESP+0x18]
 8048872: MOV [ESP+EDX*4+0x20], EAX
 8048876: MOV EAX, [ESP+0x18]
 804887a: MOV [ESP+0x4], EAX
 804887e: MOV DWORD [ESP], 0x8048abd ; 'object #%d created\n'
 8048885: CALL 8048490 <printf>
 804888a: JMP 0x80487d0
; }
 804888f: MOVZX EAX, BYTE [ESP+0x16]
 8048894: CMP AL, 0x61 ;
 8048896: JNZ 0x80488b8 ; if(AL == 'a') {
 8048898: MOV EAX, [ESP+0x18]
 804889c: MOV [ESP], EAX
 804889f: CALL 8048727 <get_choice>
 80488a4: MOV EAX, [ESP+EAX*4+0x20]
 80488a8: ADD EAX, 0x4
 80488ab: MOV [ESP], EAX
 80488ae: CALL 8048674 <read_a>
 80488b3: JMP 0x804894b
; }
 80488b8: MOVZX EAX, BYTE [ESP+0x16]
 80488bd: CMP AL, 0x62 ;
 80488bf: JNZ 0x80488de ; if(AL == 'b') {
 80488c1: MOV EAX, [ESP+0x18]
 80488c5: MOV [ESP], EAX
 80488c8: CALL 8048727 <get_choice>
 80488cd: MOV EAX, [ESP+EAX*4+0x20]
 80488d1: ADD EAX, 0x4
 80488d4: MOV [ESP], EAX
 80488d7: CALL 804869b <read_b>
 80488dc: JMP 0x804894b
; }
 80488de: MOVZX EAX, BYTE [ESP+0x16]
 80488e3: CMP AL, 0x66 ;
 80488e5: JNZ 0x8048901 ; if(AL == 'f') {
 80488e7: MOV EAX, [ESP+0x18]
 80488eb: MOV [ESP], EAX
 80488ee: CALL 8048727 <get_choice>
 80488f3: MOV EAX, [ESP+EAX*4+0x20]
 80488f7: MOV [ESP], EAX
 80488fa: CALL 804870f <free_heap_obj>
 80488ff: JMP 0x804894b
; }
 8048901: MOVZX EAX, BYTE [ESP+0x16]
 8048906: CMP AL, 0x65 ;
 8048908: JNZ 0x8048936 ; if(AL == 'e') {
 804890a: MOV EAX, [ESP+0x18]
 804890e: MOV [ESP], EAX
 8048911: CALL 8048727 <get_choice>
 8048916: MOV [ESP+0x1c], EAX
 804891a: MOV EAX, [ESP+0x1c]
 804891e: MOV EAX, [ESP+EAX*4+0x20]
 8048922: MOV EAX, [EAX]
 8048924: MOV EDX, [ESP+0x1c]
 8048928: MOV EDX, [ESP+EDX*4+0x20]
 804892c: ADD EDX, 0x4
 804892f: MOV [ESP], EDX
 8048932: CALL EAX
 8048934: JMP 0x804894b
; }
 8048936: MOVZX EAX, BYTE [ESP+0x16]
 804893b: CMP AL, 0x71 ;
 804893d: JNZ 0x804894b ; if(AL == 'q') {
 804893f: MOV DWORD [ESP], 0x0
 8048946: CALL 8048510 <exit>
; }
 804894b: JMP 0x80487d0
__libc_csu_init:
 8048950: PUSH EBP
 8048951: PUSH EDI
 8048952: XOR EDI, EDI
 8048954: PUSH ESI
 8048955: PUSH EBX
 8048956: CALL 8048570 <__x86.get_pc_thunk.bx> ; EBX = 0x804895b
 804895b: ADD EBX, 0x16a5
 8048961: SUB ESP, 0x1c
 8048964: MOV EBP, [ESP+0x30]
 8048968: LEA ESI, [EBX-0xf4]  ; 0x8049f0c '\xf0\x85\x04\x08'
 804896e: CALL 8048448 <sub_8048448>
 8048973: LEA EAX, [EBX-0xf8]  ; 0x8049f08 '\x10\x86\x04\x08'
 8048979: SUB ESI, EAX
 804897b: SAR ESI, 0x2
 804897e: TEST ESI, ESI ;
 8048980: JZ 0x80489a9 ; if(ESI) {
 8048982: LEA ESI, [ESI+0x0]
 8048988: MOV EAX, [ESP+0x38]
 804898c: MOV [ESP], EBP
 804898f: MOV [ESP+0x8], EAX
 8048993: MOV EAX, [ESP+0x34]
 8048997: MOV [ESP+0x4], EAX
 804899b: CALL DWORD [EBX+EDI*4-0xf8]
 80489a2: ADD EDI, 0x1
 80489a5: CMP EDI, ESI ;
 80489a7: JNZ 0x8048988 ; } while(EDI != ESI)
; }
 80489a9: ADD ESP, 0x1c
 80489ac: POP EBX
 80489ad: POP ESI
 80489ae: POP EDI
 80489af: POP EBP
 80489b0: RET
 80489b1: JMP 0x80489c0
 80489b3: NOP
 80489b4: NOP
 80489b5: NOP
 80489b6: NOP
 80489b7: NOP
 80489b8: NOP
 80489b9: NOP
 80489ba: NOP
 80489bb: NOP
 80489bc: NOP
 80489bd: NOP
 80489be: NOP
 80489bf: NOP
__libc_csu_fini:
 80489c0: RET
.fini:
:
 80489c4: PUSH EBX
 80489c5: SUB ESP, 0x8
 80489c8: CALL 8048570 <__x86.get_pc_thunk.bx> ; EBX = 0x80489cd
 80489cd: ADD EBX, 0x1633
 80489d3: ADD ESP, 0x8
 80489d6: POP EBX
 80489d7: RET
